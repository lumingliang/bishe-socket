(function() {
  var EventEmitter, RLSocketClient, net, readline,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  net = require('net');

  readline = require('readline');

  EventEmitter = require('events').EventEmitter;

  module.exports = RLSocketClient = (function(superClass) {
    var rl, socket;

    extend(RLSocketClient, superClass);

    rl = null;

    socket = null;

    function RLSocketClient(opts) {
      this.write = bind(this.write, this);
      this.connect = bind(this.connect, this);
      var ref, ref1, ref2, ref3, ref4, ref5;
      if (!(opts && opts.host && opts.port)) {
        throw new Error('A socket host and port are required.');
      }
      this.host = (ref = opts.host) != null ? ref : null;
      this.port = (ref1 = opts.port) != null ? ref1 : null;
      this.prompt = (ref2 = opts.prompt) != null ? ref2 : '> ';
      this.lineEnding = (ref3 = opts.lineEnding) != null ? ref3 : '\r\n';
      this.completions = (ref4 = opts.completions) != null ? ref4 : [];
      this.autoConnect = (ref5 = opts.connect) != null ? ref5 : false;
      socket = new net.Socket();
      socket.setNoDelay(true);
      rl = readline.createInterface({
        input: process.stdin,
        output: process.stdout,
        completer: (function(_this) {
          return function(line) {
            var hits;
            hits = _this.completions.filter(function(cmd) {
              return cmd.indexOf(line) === 0;
            });
            if (hits.length) {
              return [hits, line];
            }
            return [_this.completions, line];
          };
        })(this)
      });
      rl.setPrompt(this.prompt);
      rl.on('SIGINT', function() {
        return rl.question('Really quit? (y/n) ', function(res) {
          if (res === 'n') {
            return rl.prompt();
          }
          return (rl.close() && socket.end() && process.exit(0)) || (process.exit(128));
        });
      }).on('SIGCONT', function() {
        return rl.prompt();
      }).on('line', (function(_this) {
        return function(text) {
          return socket.write("" + text + _this.lineEnding);
        };
      })(this));
      socket.on('lookup', function(err, address, family) {
        if (err) {
          console.error(err);
        }
        console.log('SOCKET HOST ADDRESS LOOKUP');
        console.log('HOST ADDRESS', address);
        return console.log('HOST FAMILY', family);
      }).on('data', function(data) {
        console.log(data.toString());
        return rl.prompt();
      }).on('timeout', function() {
        console.log('CONNECTION TIMEOUT');
        return socket.end();
      }).on('error', function(err) {
        console.error('CONNECTION ERROR', err);
        return socket.destroy();
      }).on('end', function() {
        return console.log('CONNECTION CLOSED');
      });
      if (this.autoConnect) {
        this.connect();
      }
    }

    RLSocketClient.prototype.connect = function() {
      return socket.connect(this.port, this.host, (function(_this) {
        return function() {
          process.nextTick(function() {
            return _this.emit('connected');
          });
          console.log('ESTABLISHED CONNECTION to %s:%d', _this.host, _this.port);
          rl.prompt();
          return _this;
        };
      })(this));
    };

    RLSocketClient.prototype.write = function(text) {
      console.log(text);
      socket.write("" + text + this.lineEnding);
      return this;
    };

    return RLSocketClient;

  })(EventEmitter);

}).call(this);
